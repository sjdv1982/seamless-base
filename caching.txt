# Caching, done right

The buffer cache contains two Checksum-to-Buffer caches: a weak cache (WeakValueDictionary) 
and a strong cache (standard dict).

Checksum.resolve() is the operation that is being cached. 
Upon completion, Checksum.resolve() (in case of a cache miss) and Buffer.get_checksum() register their result *buffer* with the weak buffer cache (NOTE 1).
The same happens whenever a Buffer is contructed.

In addition, it is possible to register a *checksum* in the ref repository. 
This causes current cached buffers and future buffer registrations for that checksum to move to the strong cache. 
There are two kind of refs: normal refs that have an "interest" of 1, and temprefs that 
start with a high interest that fades over time (NOTE 2).  Normal refs can be incref'ed and decref'ed. 
One tempref (which can be refreshed) is allowed per checksum. Once a checksum has no refs at all, cached buffers are moved back 
to the weak cache.

## Eviction

Eviction is the concept of moving buffers from the strong cache to the weak cache even while refs exist. 
The decision to evict is as a balance of eviction loss and eviction benefit. Eviction loss is calculated as 
C * I, where I is the interest and C is the cost. C depends on the cost of downloading or recalculating a buffer 
(NOTE 3).
Eviction benefit depends on the memory usage, i.e. the size of the buffers in the strong cache. Below the soft memory
cap, eviction has no benefit. Above the hard memory cap, eviction benefit is infinite. In between two caps, 
eviction benefit has a per-GB value. 
Eviction happens periodically, and during evictions, buffers with the lowest cost-per-GB are evicted first.
In between evictions, buffer registrations are always accepted even if they surpass the hard memory cap.

## Cost calculation

In many cases, the eviction cost is simply the download cost. 
However, if the buffer is a scratch buffer, i.e. it is not stored but its provenance is stored, 
then the central buffer cache can calculate the eviction cost from the provenance, as the combined 
download/calculation costs of the minimal path in the dependency graph.

For this purpose, the central buffer cache maintains, for all checksums in strong cache:
- The known upstream transformations (checksum-to-checksum)
- The known upstream conversions (checksum-to-checksum. Coming from expressions, join and syn2sem: each attach a bit of data to the conversion)
- The upstream dependencies (which are checksums), direct and indirect, in the form of a cached-checksum-to-dependencies mapping.
- A refcount of the dependencies in the mapping.
- The upstream transformations and conversions of the dependencies
- The buffer lengths of the dependencies. Dependencies with unknown buffer length have an infinite download cost.

If a new checksum becomes of interest (added to the cache or becomes a dependency), then the subsystems are queried 
for the above data.
Such queries are normally pooled (batched) for effiency. Subsystems can also notify the central system that a buffer 
of interest has been changed.
If a checksum gets evicted (or a dependency goes out of refcount) its associated data become forgotten by 
the central system.
Subsystems forget nothing (NOTE 4): if something unknown is queried, a server may be contacted or a syscall performed, 
but only then. 

There are the following subsystems:

- The download cost subsystem. This is connected to the read buffer system and the hashserver system. 
Whenever something is *uploaded* to a hashserver, the download cost system gets cleared for that checksum 
(and the central system notified if it is of interest)
- The transformation subsystem. This is connected to the database system and the transformation execution machinery. 
Whenever a new transformation has been executed, the result and resource cost (CPU time) get stored.
If the result checksum is of interest, the central system gets notified.
- The conversion subsystem. This is connected to the database system and to the machinery to evaluate expression/join/sem2syn tasks.
Whenever a new conversion has been completed, the result gets stored and the central system gets notified.
- The buffer length subsystem. This is connected to the database system, the read buffer system and the hashserver system.
Whenever a buffer is registered in the weak or strong buffer cache, the buffer length subsystem gets notified.

The download and transformation subsystems will support cost plugins, to calculate costs in a smarter way. 
Transformation cost plugins may calculate either CPU time or directly calculate units.

NOTE 1: Both have a fully functional async version. The sync version of Checksum.resolve() is crippled inside Jupyter,
because the event loop is already running.

NOTE 2: For example, an initial interest of 128, a factor 2 fade every 2 seconds, and a disappearance after 28 seconds.

NOTE 3: 
By default, C is 1 unit / GB for read_buffer_folders by assuming a read speed of 1GB/sec. 
This is the reference definition of a cost unit.
Proposed defaults:
- 10 units / GB for a local (intra-cluster) network hashserver, with a minimum of 0.001 units. 
- 100 units / GB for a non-local network hashserver, with a minimum of 0.01 units
- Conversions (expression evaluations) have no cost (other than the cost of the upstream dependency buffer)
- 0.1 unit per CPU second for transformations (on top of the upstream dependencies). 
  By default, transformations are assumed to last a CPU hour, i.e. 360 units. 
  In other words, with negligible upstream buffers, for a 10 min computation, 
  re-computation is preferred to download for 36 GB in a read buffer folder, 3.6 GB over a local network,
  or 360 MB over a remote network.

  NOTE 4: In fact, a LRU cache. Proposed default size: 100 million.

  NOTE 5: Sensible defaults: a soft memory cap of 5 GB, a hard memory cap of 50 GB, and an eviction benefit of 2 units/GB between the caps.